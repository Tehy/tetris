<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tetris JS</title>
    <style>
      body {
        font-family: "arcadeclassicregular";
        src: url("arcadeclassic-webfont.woff") format("woff");
        font-weight: normal;
        font-style: normal;

        text-align: center;
        color: whitesmoke;
      }
      p {
        font-size: large;
      }
      canvas {
      }
    </style>
  </head>
  <body>
    <h2>Tetris</h2>
    <p id="score">SCORE: 0</p>
    <!-- 20x10 play area blocks -->
    <canvas
      id="canvas"
      width="400"
      height="800"
      style="border: 0.2px solid grey;"
    ></canvas>

    <!-- TODO make canvas smaller , drawblock dynamic to width &heigth -->
    <script>
      const c = document.getElementById("canvas");
      const ctx = c.getContext("2d");
      const width = canvas.width;
      const height = canvas.height;
      const rows = 10; //game rows
      const cols = 20; //game columns
      var gameArray = [];
      const blockSize = width / 10;

      //const gameBlockSize = 4; // correct?

      const startPosition = [0, 3];

      var score = 0;

      function initGameArr() {
        //fill game matrix array and draw rect to canvas
        ctx.fillStyle = "grey";
        ctx.fillRect(0, 0, width, height);
        for (var i = 0; i < cols; i++) {
          gameArray[i] = [];
          for (var j = 0; j < rows; j++) {
            gameArray[i][j] = 0;
            ctx.lineWidth = 0.2;
            ctx.strokeRect(j * blockSize, i * blockSize, blockSize, blockSize);
          }
        }
      }
      initGameArr();

      function clearBoard() {
        //initGameArr();
        for (var i = 0; i < cols; i++) {
          for (var j = 0; j < rows; j++) {
            if (gameArray[i][j] === 0) {
              drawBlock(i, j, blockSize, "grey");
            } else if (gameArray[i][j] === "b") {
              drawBlock(i, j, blockSize, "blue");
            } else if (gameArray[i][j] === "d") {
              drawBlock(i, j, blockSize, "darkOrange");
            } else if (gameArray[i][j] === "y") {
              drawBlock(i, j, blockSize, "yellow");
            } else if (gameArray[i][j] === "f") {
              drawBlock(i, j, blockSize, "forestGreen");
            } else if (gameArray[i][j] === "r") {
              drawBlock(i, j, blockSize, "red");
            } else if (gameArray[i][j] === "a") {
              drawBlock(i, j, blockSize, "aqua");
            }
          }
        }
      }
      function drawBlock(x, y, size, color) {
        ctx.fillStyle = color;
        ctx.fillRect(y * size, x * size, size, size);
        ctx.lineWidth = 0.2;
        ctx.strokeRect(y * blockSize, x * blockSize, blockSize, blockSize);
      }
      var colors = [
        "blue",
        "red",
        "yellow",
        "darkOrange",
        "forestGreen",
        "aqua",
      ];

      function checkRowsFull() {
        let rowsToClear = [];
        for (var i = 0; i < cols; i++) {
          // todo, optimize, break at first 0
          gameArray[i].includes(0) ? null : rowsToClear.push(i);
        }
        return rowsToClear;
      }
      function clearRow(rowIndex) {
        for (var i = 0; i < 10; i++) {
          gameArray[rowIndex][i] = 0;
        }
        clearBoard();
      }

      function delRows(rowsToClear) {
        // draw fullrows grey
        rowsLen = rowsToClear.length;
        for (var i = 0; i < rowsLen; i++) {
          clearRow(rowsToClear[i]);
        }

        for (var i = rowsLen - 1; i >= 0; i--) {
          gameArray.splice(rowsToClear[i], 1);
          //gameArray.unshift([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
        }
        for (var i = 0; i < rowsLen; i++) {
          gameArray.unshift([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
        }
        score += rowsLen;
        updateScore();
        //console.log("score", score);
        // TODO update score to windnow
        clearBoard();
      }

      class Piece {
        constructor() {
          this.color = colors[Math.floor(Math.random() * colors.length)];
          this.checkKey = function (e) {
            e = e || window.event;
            //console.log("e.keyCode", e.keyCode);
            switch (e.keyCode) {
              case 37:
                this.moveLeft();
                break;
              case 39:
                this.moveRight();
                break;
              case 38:
                this.rotate();
                break;
              case 40:
                this.moveDown();
                break;
              case 32:
                console.log("todo placeBlock()/dropBlock()");
                this.placeBlock();
                break;
            }
          };
          this.keyDownHandler = this.checkKey.bind(this);
          window.addEventListener("keydown", this.keyDownHandler);
        }

        kill() {
          //this.draw();

          window.removeEventListener("keydown", this.keyDownHandler);
          this.alive = false;

          //console.log("piece killed()");

          for (var i = 0; i < 4; i++) {
            for (var j = 0; j < 4; j++) {
              // draw piece cells === 1
              if (this.array[this.currentRotation][i][j] !== 0) {
                gameArray[this.position[0] + i][
                  this.position[1] + j
                ] = this.color[0];
                drawBlock(
                  this.position[0] + i,
                  this.position[1] + j,
                  40,
                  this.color
                );
              }
            }
          }
          this.position = [0, 3];
          delRows(checkRowsFull());

          //console.log("this.position", this.position);
          //console.log("startPosition", startPosition);

          //stopInterval();
          //delete this.Piece;
          //var piece = spawnPiece();
          //var gameInterval = startInterval();
          //console.log("piece", piece);
        }

        draw() {
          if (this.alive === true) {
            for (var i = 0; i < 4; i++) {
              for (var j = 0; j < 4; j++) {
                // draw piece cells === 1
                if (this.array[this.currentRotation][i][j] !== 0) {
                  gameArray[this.position[0] + i][this.position[1] + j] = 1;
                  drawBlock(
                    this.position[0] + i,
                    this.position[1] + j,
                    40,
                    this.color
                  );
                }
              }
            }
            clearBoard();
          }
        }

        moveDown() {
          if (this.alive) {
            this.nullifyPiecePos();
            let moveValid = true;
            for (var i = 0; i < 4; i++) {
              for (var j = 3; j >= 0; j--) {
                if (this.array[this.currentRotation][j][i] === 1) {
                  /* TODO check collision works */

                  try {
                    if (
                      gameArray[this.position[0] + j + 1][
                        this.position[1] + i
                      ] !== 0
                    ) {
                      moveValid = false;
                      break;
                    }
                  } catch (err) {
                    moveValid = false;
                    break;
                  }
                  break;
                }
              }
            }
            moveValid ? (this.position[0]++, this.draw()) : this.kill();
          }
        }
        nullifyPiecePos() {
          for (var i = 0; i < 4; i++) {
            for (var j = 0; j < 4; j++) {
              if (this.array[this.currentRotation][i][j] === 1) {
                gameArray[this.position[0] + i][this.position[1] + j] = 0;
              }
            }
          }
        }

        moveLeft() {
          if (this.alive) {
            let moveValid = true;
            for (var i = 0; i < 4; i++) {
              for (var j = 0; j < 4; j++) {
                if (this.array[this.currentRotation][i][j] === 1) {
                  if (
                    gameArray[this.position[0] + i][
                      this.position[1] + j - 1
                    ] !== 0 ||
                    gameArray[this.position[0] + i][
                      this.position[1] + j - 1
                    ] === undefined
                  ) {
                    moveValid = false;
                    break;
                  }
                  break;
                }
              }
            }
            moveValid
              ? (this.nullifyPiecePos(), this.position[1]--, this.draw())
              : null;
          }
        }

        moveRight() {
          if (this.alive) {
            let moveValid = true;
            for (var i = 0; i < 4; i++) {
              for (var j = 3; j > 0; j--) {
                if (this.array[this.currentRotation][i][j] === 1) {
                  if (
                    gameArray[this.position[0] + i][
                      this.position[1] + j + 1
                    ] !== 0 ||
                    gameArray[this.position[0] + i][
                      this.position[1] + j + 1
                    ] === undefined
                  ) {
                    moveValid = false;
                    break;
                  }
                  break;
                }
              }
            }
            //console.log("moveValid", moveValid);

            moveValid
              ? (this.nullifyPiecePos(), this.position[1]++, this.draw())
              : null;
          }
        }

        rotate() {
          if (this.alive) {
            this.nullifyPiecePos();

            let rotationValid = true;

            let newRotation =
              this.currentRotation < this.rotations
                ? this.currentRotation + 1
                : 0;

            let newRotationArray = [...this.array[newRotation]];
            for (var i = 0; i < 4; i++) {
              for (var j = 0; j < 4; j++) {
                if (newRotationArray[i][j] === 1) {
                  try {
                    // TODO if undefined -> overboard -> move left/right, to enable rotation next to wall
                    if (
                      gameArray[this.position[0] + i][this.position[1] + j] !==
                        0 ||
                      gameArray[this.position[0] + i][this.position[1] + j] ===
                        undefined
                    ) {
                      rotationValid = false;
                    }
                  } catch (err) {
                    rotationValid = false;
                  }
                }
              }
            }

            // TODO rotate next to block or wall, move() away from wall, if no adjasing blocks === 1 or undefined
            rotationValid
              ? ((this.currentRotation = newRotation), this.draw())
              : null;
          }
        }
      }
      function randomRotation(rotations) {
        return Math.floor(Math.random() * Math.floor(rotations + 1));
      }
      class Zpiece1 extends Piece {
        constructor(position) {
          super();
          this.alive = true;
          this.position = position;
          this.array = [
            [
              [0, 0, 0, 0],
              [0, 0, 0, 0],
              [1, 1, 0, 0],
              [0, 1, 1, 0],
            ],
            [
              [0, 0, 0, 0],
              [0, 1, 0, 0],
              [1, 1, 0, 0],
              [1, 0, 0, 0],
            ],
          ];
          this.rotations = this.array.length - 1;
          this.currentRotation = randomRotation(this.rotations);
        }
      }
      class Zpiece2 extends Piece {
        constructor(position) {
          super();
          this.alive = true;
          this.position = position;
          this.array = [
            [
              [0, 0, 0, 0],
              [0, 0, 0, 0],
              [0, 1, 1, 0],
              [1, 1, 0, 0],
            ],
            [
              [0, 0, 0, 0],
              [1, 0, 0, 0],
              [1, 1, 0, 0],
              [0, 1, 0, 0],
            ],
          ];
          this.rotations = this.array.length - 1;
          this.currentRotation = randomRotation(this.rotations);
        }
      }
      class Ipiece extends Piece {
        constructor(position) {
          super();
          this.alive = true;
          this.position = position;
          this.array = [
            [
              [0, 0, 0, 0],
              [1, 1, 1, 1],
              [0, 0, 0, 0],
              [0, 0, 0, 0],
            ],
            [
              [0, 1, 0, 0],
              [0, 1, 0, 0],
              [0, 1, 0, 0],
              [0, 1, 0, 0],
            ],
          ];
          this.rotations = this.array.length - 1;
          this.currentRotation = randomRotation(this.rotations);
        }
      }
      class Lpiece1 extends Piece {
        constructor(position) {
          super();
          this.alive = true;
          this.position = position;
          this.array = [
            [
              [0, 0, 0, 0],
              [0, 1, 0, 0],
              [0, 1, 0, 0],
              [1, 1, 0, 0],
            ],
            [
              [0, 0, 0, 0],
              [1, 0, 0, 0],
              [1, 1, 1, 0],
              [0, 0, 0, 0],
            ],
            [
              [0, 0, 0, 0],
              [0, 1, 1, 0],
              [0, 1, 0, 0],
              [0, 1, 0, 0],
            ],
            [
              [0, 0, 0, 0],
              [0, 0, 0, 0],
              [1, 1, 1, 0],
              [0, 0, 1, 0],
            ],
          ];
          this.rotations = this.array.length - 1;
          this.currentRotation = randomRotation(this.rotations);
        }
      }
      class Lpiece2 extends Piece {
        constructor(position) {
          super();
          this.alive = true;
          this.position = position;
          this.array = [
            [
              [0, 0, 0, 0],
              [0, 1, 0, 0],
              [0, 1, 0, 0],
              [0, 1, 1, 0],
            ],
            [
              [0, 0, 0, 0],
              [0, 0, 0, 0],
              [1, 1, 1, 0],
              [1, 0, 0, 0],
            ],
            [
              [0, 0, 0, 0],
              [1, 1, 0, 0],
              [0, 1, 0, 0],
              [0, 1, 0, 0],
            ],
            [
              [0, 0, 0, 0],
              [0, 0, 1, 0],
              [1, 1, 1, 0],
              [0, 0, 0, 0],
            ],
          ];
          this.rotations = this.array.length - 1;
          this.currentRotation = randomRotation(this.rotations);
        }
      }
      class Epiece extends Piece {
        constructor(position) {
          super();
          this.alive = true;
          this.position = position;
          this.array = [
            [
              [0, 0, 0, 0],
              [0, 1, 0, 0],
              [1, 1, 1, 0],
              [0, 0, 0, 0],
            ],
            [
              [0, 0, 0, 0],
              [0, 1, 0, 0],
              [1, 1, 0, 0],
              [0, 1, 0, 0],
            ],
            [
              [0, 0, 0, 0],
              [0, 0, 0, 0],
              [1, 1, 1, 0],
              [0, 1, 0, 0],
            ],
            [
              [0, 0, 0, 0],
              [0, 1, 0, 0],
              [0, 1, 1, 0],
              [0, 1, 0, 0],
            ],
          ];
          this.rotations = this.array.length - 1;
          this.currentRotation = randomRotation(this.rotations);
        }
      }
      class Bpiece extends Piece {
        constructor(position) {
          super();
          this.alive = true;
          this.position = position;
          this.array = [
            [
              [0, 0, 0, 0],
              [0, 1, 1, 0],
              [0, 1, 1, 0],
              [0, 0, 0, 0],
            ],
          ];
          this.rotations = this.array.length - 1;
          this.currentRotation = randomRotation(this.rotations);
        }
      }
      const pieces = [
        Ipiece,
        Bpiece,
        Zpiece1,
        Zpiece2,
        Lpiece1,
        Lpiece2,
        Epiece,
      ];

      function spawnPiece() {
        //if (piece) piece.position = [0, 3];
        var randomPiece = pieces[Math.floor(Math.random() * pieces.length)];
        var p = new randomPiece([0, 3]);
        //check if piece spawns ontop of other piece
        for (var i = 0; i < 4; i++) {
          for (var j = 0; j < 4; j++) {
            if (p.array[p.currentRotation][i][j] === 1) {
              if (gameArray[p.position[0] + i][p.position[1] + j] !== 0) {
                p.kill();
                document.querySelector("#score").innerHTML =
                  "GAME OVER! your score: " + score;
                clearInterval(gameInterval);
                //console.log("p.position", p.position);
              }
            }
          }
        }

        return p;
      }
      function stopInterval() {
        clearInterval(gameInterval);
      }
      function startInterval() {
        gameInterval = setInterval(() => {
          piece !== undefined && piece.alive
            ? piece.moveDown()
            : ((piece.position = [0, 3]), (piece = spawnPiece()));
        }, 500);
      }

      // init game
      piece = spawnPiece();
      piece.draw();
      var gameInterval = setInterval(() => {
        piece !== undefined && piece.alive
          ? piece.moveDown()
          : ((piece.position = [0, 3]), (piece = spawnPiece()));
      }, 500);
      //clearInterval(gameInterval);

      var paused = false;
      function pause() {
        return paused
          ? ((paused = false), startInterval())
          : ((paused = true), stopInterval());
      }
      function start() {
        score = 0;
        paused = false;
        initGameArr();
        piece = spawnPiece();
        piece.draw();
        startInterval();
      }
      function updateScore() {
        document.querySelector("#score").innerHTML = "SCORE: " + score;
      }

      function restart() {
        stopInterval();
        score = 0;
        paused = false;
        initGameArr();
        piece = spawnPiece();
        piece.draw();
        startInterval();
      }
    </script>
  </body>
</html>
